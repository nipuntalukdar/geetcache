// Code generated by Thrift Compiler (0.16.0). DO NOT EDIT.

package thrift

import (
	"bytes"
	"context"
	"database/sql/driver"
	"errors"
	"fmt"
	"time"
	thrift "github.com/apache/thrift/lib/go/thrift"
)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = context.Background
var _ = time.Now
var _ = bytes.Equal

type Status int64
const (
  Status_SUCCESS Status = 0
  Status_FAILURE Status = 1
  Status_KEY_EXISTS Status = 2
  Status_KEY_NOT_EXISTS Status = 3
  Status_EMPTY_LIST Status = 4
  Status_LEADER_NOT_FOUND Status = 5
  Status_NOT_LEADER Status = 6
  Status_BAD_COMMAND Status = 7
)

func (p Status) String() string {
  switch p {
  case Status_SUCCESS: return "SUCCESS"
  case Status_FAILURE: return "FAILURE"
  case Status_KEY_EXISTS: return "KEY_EXISTS"
  case Status_KEY_NOT_EXISTS: return "KEY_NOT_EXISTS"
  case Status_EMPTY_LIST: return "EMPTY_LIST"
  case Status_LEADER_NOT_FOUND: return "LEADER_NOT_FOUND"
  case Status_NOT_LEADER: return "NOT_LEADER"
  case Status_BAD_COMMAND: return "BAD_COMMAND"
  }
  return "<UNSET>"
}

func StatusFromString(s string) (Status, error) {
  switch s {
  case "SUCCESS": return Status_SUCCESS, nil 
  case "FAILURE": return Status_FAILURE, nil 
  case "KEY_EXISTS": return Status_KEY_EXISTS, nil 
  case "KEY_NOT_EXISTS": return Status_KEY_NOT_EXISTS, nil 
  case "EMPTY_LIST": return Status_EMPTY_LIST, nil 
  case "LEADER_NOT_FOUND": return Status_LEADER_NOT_FOUND, nil 
  case "NOT_LEADER": return Status_NOT_LEADER, nil 
  case "BAD_COMMAND": return Status_BAD_COMMAND, nil 
  }
  return Status(0), fmt.Errorf("not a valid Status string")
}


func StatusPtr(v Status) *Status { return &v }

func (p Status) MarshalText() ([]byte, error) {
return []byte(p.String()), nil
}

func (p *Status) UnmarshalText(text []byte) error {
q, err := StatusFromString(string(text))
if (err != nil) {
return err
}
*p = q
return nil
}

func (p *Status) Scan(value interface{}) error {
v, ok := value.(int64)
if !ok {
return errors.New("Scan value is not int64")
}
*p = Status(v)
return nil
}

func (p * Status) Value() (driver.Value, error) {
  if p == nil {
    return nil, nil
  }
return int64(*p), nil
}
// Attributes:
//  - Key
//  - Data
//  - Expiry
type PutCommand struct {
  Key string `thrift:"Key,1" db:"Key" json:"Key"`
  Data []byte `thrift:"Data,2" db:"Data" json:"Data"`
  Expiry int64 `thrift:"Expiry,3" db:"Expiry" json:"Expiry"`
}

func NewPutCommand() *PutCommand {
  return &PutCommand{}
}


func (p *PutCommand) GetKey() string {
  return p.Key
}

func (p *PutCommand) GetData() []byte {
  return p.Data
}

func (p *PutCommand) GetExpiry() int64 {
  return p.Expiry
}
func (p *PutCommand) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *PutCommand)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Key = v
}
  return nil
}

func (p *PutCommand)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Data = v
}
  return nil
}

func (p *PutCommand)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Expiry = v
}
  return nil
}

func (p *PutCommand) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "PutCommand"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *PutCommand) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "Key", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:Key: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Key)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.Key (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:Key: ", p), err) }
  return err
}

func (p *PutCommand) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "Data", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:Data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Data); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.Data (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:Data: ", p), err) }
  return err
}

func (p *PutCommand) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "Expiry", thrift.I64, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:Expiry: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.Expiry)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.Expiry (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:Expiry: ", p), err) }
  return err
}

func (p *PutCommand) Equals(other *PutCommand) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Key != other.Key { return false }
  if bytes.Compare(p.Data, other.Data) != 0 { return false }
  if p.Expiry != other.Expiry { return false }
  return true
}

func (p *PutCommand) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("PutCommand(%+v)", *p)
}

// Attributes:
//  - Key
//  - Stat
type DelResponse struct {
  Key string `thrift:"Key,1" db:"Key" json:"Key"`
  Stat Status `thrift:"Stat,2" db:"Stat" json:"Stat"`
}

func NewDelResponse() *DelResponse {
  return &DelResponse{}
}


func (p *DelResponse) GetKey() string {
  return p.Key
}

func (p *DelResponse) GetStat() Status {
  return p.Stat
}
func (p *DelResponse) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *DelResponse)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Key = v
}
  return nil
}

func (p *DelResponse)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := Status(v)
  p.Stat = temp
}
  return nil
}

func (p *DelResponse) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "DelResponse"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *DelResponse) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "Key", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:Key: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Key)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.Key (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:Key: ", p), err) }
  return err
}

func (p *DelResponse) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "Stat", thrift.I32, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:Stat: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Stat)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.Stat (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:Stat: ", p), err) }
  return err
}

func (p *DelResponse) Equals(other *DelResponse) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Key != other.Key { return false }
  if p.Stat != other.Stat { return false }
  return true
}

func (p *DelResponse) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("DelResponse(%+v)", *p)
}

// Attributes:
//  - Stat
//  - Leader
type LeaderResponse struct {
  Stat Status `thrift:"Stat,1" db:"Stat" json:"Stat"`
  Leader string `thrift:"Leader,2" db:"Leader" json:"Leader"`
}

func NewLeaderResponse() *LeaderResponse {
  return &LeaderResponse{}
}


func (p *LeaderResponse) GetStat() Status {
  return p.Stat
}

func (p *LeaderResponse) GetLeader() string {
  return p.Leader
}
func (p *LeaderResponse) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *LeaderResponse)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  temp := Status(v)
  p.Stat = temp
}
  return nil
}

func (p *LeaderResponse)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Leader = v
}
  return nil
}

func (p *LeaderResponse) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "LeaderResponse"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *LeaderResponse) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "Stat", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:Stat: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Stat)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.Stat (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:Stat: ", p), err) }
  return err
}

func (p *LeaderResponse) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "Leader", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:Leader: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Leader)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.Leader (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:Leader: ", p), err) }
  return err
}

func (p *LeaderResponse) Equals(other *LeaderResponse) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Stat != other.Stat { return false }
  if p.Leader != other.Leader { return false }
  return true
}

func (p *LeaderResponse) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("LeaderResponse(%+v)", *p)
}

// Attributes:
//  - Stat
//  - Peers
type PeersResponse struct {
  Stat Status `thrift:"Stat,1" db:"Stat" json:"Stat"`
  Peers []string `thrift:"Peers,2" db:"Peers" json:"Peers,omitempty"`
}

func NewPeersResponse() *PeersResponse {
  return &PeersResponse{}
}


func (p *PeersResponse) GetStat() Status {
  return p.Stat
}
var PeersResponse_Peers_DEFAULT []string

func (p *PeersResponse) GetPeers() []string {
  return p.Peers
}
func (p *PeersResponse) IsSetPeers() bool {
  return p.Peers != nil
}

func (p *PeersResponse) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *PeersResponse)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  temp := Status(v)
  p.Stat = temp
}
  return nil
}

func (p *PeersResponse)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]string, 0, size)
  p.Peers =  tSlice
  for i := 0; i < size; i ++ {
var _elem0 string
    if v, err := iprot.ReadString(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem0 = v
}
    p.Peers = append(p.Peers, _elem0)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *PeersResponse) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "PeersResponse"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *PeersResponse) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "Stat", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:Stat: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Stat)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.Stat (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:Stat: ", p), err) }
  return err
}

func (p *PeersResponse) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetPeers() {
    if err := oprot.WriteFieldBegin(ctx, "Peers", thrift.LIST, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:Peers: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.Peers)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Peers {
      if err := oprot.WriteString(ctx, string(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:Peers: ", p), err) }
  }
  return err
}

func (p *PeersResponse) Equals(other *PeersResponse) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Stat != other.Stat { return false }
  if len(p.Peers) != len(other.Peers) { return false }
  for i, _tgt := range p.Peers {
    _src1 := other.Peers[i]
    if _tgt != _src1 { return false }
  }
  return true
}

func (p *PeersResponse) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("PeersResponse(%+v)", *p)
}

// Attributes:
//  - Key
//  - Status
//  - Data
type GetResponse struct {
  Key string `thrift:"Key,1" db:"Key" json:"Key"`
  Status Status `thrift:"Status,2" db:"Status" json:"Status"`
  Data []byte `thrift:"Data,3" db:"Data" json:"Data,omitempty"`
}

func NewGetResponse() *GetResponse {
  return &GetResponse{}
}


func (p *GetResponse) GetKey() string {
  return p.Key
}

func (p *GetResponse) GetStatus() Status {
  return p.Status
}
var GetResponse_Data_DEFAULT []byte

func (p *GetResponse) GetData() []byte {
  return p.Data
}
func (p *GetResponse) IsSetData() bool {
  return p.Data != nil
}

func (p *GetResponse) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *GetResponse)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Key = v
}
  return nil
}

func (p *GetResponse)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := Status(v)
  p.Status = temp
}
  return nil
}

func (p *GetResponse)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Data = v
}
  return nil
}

func (p *GetResponse) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "GetResponse"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *GetResponse) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "Key", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:Key: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Key)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.Key (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:Key: ", p), err) }
  return err
}

func (p *GetResponse) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "Status", thrift.I32, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:Status: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Status)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.Status (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:Status: ", p), err) }
  return err
}

func (p *GetResponse) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetData() {
    if err := oprot.WriteFieldBegin(ctx, "Data", thrift.STRING, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:Data: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Data); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.Data (3) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:Data: ", p), err) }
  }
  return err
}

func (p *GetResponse) Equals(other *GetResponse) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Key != other.Key { return false }
  if p.Status != other.Status { return false }
  if bytes.Compare(p.Data, other.Data) != 0 { return false }
  return true
}

func (p *GetResponse) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("GetResponse(%+v)", *p)
}

// Attributes:
//  - ListKey
//  - Append
//  - Values
//  - Expiry
type ListPutCommand struct {
  ListKey string `thrift:"ListKey,1" db:"ListKey" json:"ListKey"`
  Append bool `thrift:"Append,2" db:"Append" json:"Append"`
  Values [][]byte `thrift:"Values,3" db:"Values" json:"Values"`
  Expiry *int64 `thrift:"Expiry,4" db:"Expiry" json:"Expiry,omitempty"`
}

func NewListPutCommand() *ListPutCommand {
  return &ListPutCommand{
Append: true,
}
}


func (p *ListPutCommand) GetListKey() string {
  return p.ListKey
}

func (p *ListPutCommand) GetAppend() bool {
  return p.Append
}

func (p *ListPutCommand) GetValues() [][]byte {
  return p.Values
}
var ListPutCommand_Expiry_DEFAULT int64
func (p *ListPutCommand) GetExpiry() int64 {
  if !p.IsSetExpiry() {
    return ListPutCommand_Expiry_DEFAULT
  }
return *p.Expiry
}
func (p *ListPutCommand) IsSetExpiry() bool {
  return p.Expiry != nil
}

func (p *ListPutCommand) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ListPutCommand)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ListKey = v
}
  return nil
}

func (p *ListPutCommand)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Append = v
}
  return nil
}

func (p *ListPutCommand)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([][]byte, 0, size)
  p.Values =  tSlice
  for i := 0; i < size; i ++ {
var _elem2 []byte
    if v, err := iprot.ReadBinary(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem2 = v
}
    p.Values = append(p.Values, _elem2)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *ListPutCommand)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Expiry = &v
}
  return nil
}

func (p *ListPutCommand) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "ListPutCommand"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ListPutCommand) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "ListKey", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ListKey: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.ListKey)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.ListKey (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ListKey: ", p), err) }
  return err
}

func (p *ListPutCommand) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "Append", thrift.BOOL, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:Append: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.Append)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.Append (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:Append: ", p), err) }
  return err
}

func (p *ListPutCommand) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "Values", thrift.LIST, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:Values: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.Values)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Values {
    if err := oprot.WriteBinary(ctx, v); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:Values: ", p), err) }
  return err
}

func (p *ListPutCommand) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetExpiry() {
    if err := oprot.WriteFieldBegin(ctx, "Expiry", thrift.I64, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:Expiry: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.Expiry)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.Expiry (4) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:Expiry: ", p), err) }
  }
  return err
}

func (p *ListPutCommand) Equals(other *ListPutCommand) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.ListKey != other.ListKey { return false }
  if p.Append != other.Append { return false }
  if len(p.Values) != len(other.Values) { return false }
  for i, _tgt := range p.Values {
    _src3 := other.Values[i]
    if bytes.Compare(_tgt, _src3) != 0 { return false }
  }
  if p.Expiry != other.Expiry {
    if p.Expiry == nil || other.Expiry == nil {
      return false
    }
    if (*p.Expiry) != (*other.Expiry) { return false }
  }
  return true
}

func (p *ListPutCommand) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ListPutCommand(%+v)", *p)
}

// Attributes:
//  - ListKey
//  - MaxCount
//  - Front
type ListGPCommand struct {
  ListKey string `thrift:"ListKey,1" db:"ListKey" json:"ListKey"`
  MaxCount int32 `thrift:"MaxCount,2" db:"MaxCount" json:"MaxCount"`
  Front bool `thrift:"Front,3" db:"Front" json:"Front"`
}

func NewListGPCommand() *ListGPCommand {
  return &ListGPCommand{
MaxCount: 1,

Front: true,
}
}


func (p *ListGPCommand) GetListKey() string {
  return p.ListKey
}

func (p *ListGPCommand) GetMaxCount() int32 {
  return p.MaxCount
}

func (p *ListGPCommand) GetFront() bool {
  return p.Front
}
func (p *ListGPCommand) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ListGPCommand)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ListKey = v
}
  return nil
}

func (p *ListGPCommand)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.MaxCount = v
}
  return nil
}

func (p *ListGPCommand)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Front = v
}
  return nil
}

func (p *ListGPCommand) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "ListGPCommand"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ListGPCommand) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "ListKey", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ListKey: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.ListKey)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.ListKey (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ListKey: ", p), err) }
  return err
}

func (p *ListGPCommand) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "MaxCount", thrift.I32, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:MaxCount: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.MaxCount)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.MaxCount (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:MaxCount: ", p), err) }
  return err
}

func (p *ListGPCommand) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "Front", thrift.BOOL, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:Front: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.Front)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.Front (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:Front: ", p), err) }
  return err
}

func (p *ListGPCommand) Equals(other *ListGPCommand) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.ListKey != other.ListKey { return false }
  if p.MaxCount != other.MaxCount { return false }
  if p.Front != other.Front { return false }
  return true
}

func (p *ListGPCommand) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ListGPCommand(%+v)", *p)
}

// Attributes:
//  - ListKey
//  - Stat
//  - Retlen
//  - Values
type ListGPResponse struct {
  ListKey string `thrift:"ListKey,1" db:"ListKey" json:"ListKey"`
  Stat Status `thrift:"Stat,2" db:"Stat" json:"Stat"`
  Retlen int32 `thrift:"Retlen,3" db:"Retlen" json:"Retlen"`
  Values [][]byte `thrift:"Values,4" db:"Values" json:"Values,omitempty"`
}

func NewListGPResponse() *ListGPResponse {
  return &ListGPResponse{}
}


func (p *ListGPResponse) GetListKey() string {
  return p.ListKey
}

func (p *ListGPResponse) GetStat() Status {
  return p.Stat
}

func (p *ListGPResponse) GetRetlen() int32 {
  return p.Retlen
}
var ListGPResponse_Values_DEFAULT [][]byte

func (p *ListGPResponse) GetValues() [][]byte {
  return p.Values
}
func (p *ListGPResponse) IsSetValues() bool {
  return p.Values != nil
}

func (p *ListGPResponse) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ListGPResponse)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ListKey = v
}
  return nil
}

func (p *ListGPResponse)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := Status(v)
  p.Stat = temp
}
  return nil
}

func (p *ListGPResponse)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Retlen = v
}
  return nil
}

func (p *ListGPResponse)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([][]byte, 0, size)
  p.Values =  tSlice
  for i := 0; i < size; i ++ {
var _elem4 []byte
    if v, err := iprot.ReadBinary(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem4 = v
}
    p.Values = append(p.Values, _elem4)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *ListGPResponse) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "ListGPResponse"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ListGPResponse) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "ListKey", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ListKey: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.ListKey)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.ListKey (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ListKey: ", p), err) }
  return err
}

func (p *ListGPResponse) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "Stat", thrift.I32, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:Stat: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Stat)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.Stat (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:Stat: ", p), err) }
  return err
}

func (p *ListGPResponse) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "Retlen", thrift.I32, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:Retlen: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Retlen)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.Retlen (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:Retlen: ", p), err) }
  return err
}

func (p *ListGPResponse) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetValues() {
    if err := oprot.WriteFieldBegin(ctx, "Values", thrift.LIST, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:Values: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.Values)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Values {
      if err := oprot.WriteBinary(ctx, v); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:Values: ", p), err) }
  }
  return err
}

func (p *ListGPResponse) Equals(other *ListGPResponse) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.ListKey != other.ListKey { return false }
  if p.Stat != other.Stat { return false }
  if p.Retlen != other.Retlen { return false }
  if len(p.Values) != len(other.Values) { return false }
  for i, _tgt := range p.Values {
    _src5 := other.Values[i]
    if bytes.Compare(_tgt, _src5) != 0 { return false }
  }
  return true
}

func (p *ListGPResponse) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ListGPResponse(%+v)", *p)
}

// Attributes:
//  - ListKey
//  - LLen
//  - Stat
type ListLenResponse struct {
  ListKey string `thrift:"ListKey,1" db:"ListKey" json:"ListKey"`
  LLen int32 `thrift:"LLen,2" db:"LLen" json:"LLen"`
  Stat Status `thrift:"Stat,3" db:"Stat" json:"Stat"`
}

func NewListLenResponse() *ListLenResponse {
  return &ListLenResponse{}
}


func (p *ListLenResponse) GetListKey() string {
  return p.ListKey
}

func (p *ListLenResponse) GetLLen() int32 {
  return p.LLen
}

func (p *ListLenResponse) GetStat() Status {
  return p.Stat
}
func (p *ListLenResponse) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ListLenResponse)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ListKey = v
}
  return nil
}

func (p *ListLenResponse)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.LLen = v
}
  return nil
}

func (p *ListLenResponse)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  temp := Status(v)
  p.Stat = temp
}
  return nil
}

func (p *ListLenResponse) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "ListLenResponse"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ListLenResponse) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "ListKey", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ListKey: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.ListKey)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.ListKey (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ListKey: ", p), err) }
  return err
}

func (p *ListLenResponse) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "LLen", thrift.I32, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:LLen: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.LLen)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.LLen (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:LLen: ", p), err) }
  return err
}

func (p *ListLenResponse) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "Stat", thrift.I32, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:Stat: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Stat)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.Stat (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:Stat: ", p), err) }
  return err
}

func (p *ListLenResponse) Equals(other *ListLenResponse) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.ListKey != other.ListKey { return false }
  if p.LLen != other.LLen { return false }
  if p.Stat != other.Stat { return false }
  return true
}

func (p *ListLenResponse) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ListLenResponse(%+v)", *p)
}

// Attributes:
//  - Name
//  - Stat
//  - Value
type CStatus struct {
  Name string `thrift:"Name,1" db:"Name" json:"Name"`
  Stat Status `thrift:"Stat,2" db:"Stat" json:"Stat"`
  Value int64 `thrift:"Value,3" db:"Value" json:"Value"`
}

func NewCStatus() *CStatus {
  return &CStatus{}
}


func (p *CStatus) GetName() string {
  return p.Name
}

func (p *CStatus) GetStat() Status {
  return p.Stat
}

func (p *CStatus) GetValue() int64 {
  return p.Value
}
func (p *CStatus) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CStatus)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Name = v
}
  return nil
}

func (p *CStatus)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := Status(v)
  p.Stat = temp
}
  return nil
}

func (p *CStatus)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Value = v
}
  return nil
}

func (p *CStatus) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "CStatus"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CStatus) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "Name", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:Name: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Name)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.Name (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:Name: ", p), err) }
  return err
}

func (p *CStatus) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "Stat", thrift.I32, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:Stat: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Stat)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.Stat (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:Stat: ", p), err) }
  return err
}

func (p *CStatus) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "Value", thrift.I64, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:Value: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.Value)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.Value (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:Value: ", p), err) }
  return err
}

func (p *CStatus) Equals(other *CStatus) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Name != other.Name { return false }
  if p.Stat != other.Stat { return false }
  if p.Value != other.Value { return false }
  return true
}

func (p *CStatus) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CStatus(%+v)", *p)
}

// Attributes:
//  - Name
//  - InitialValue
//  - Replace
type CAddCommand struct {
  Name string `thrift:"Name,1" db:"Name" json:"Name"`
  InitialValue int64 `thrift:"InitialValue,2" db:"InitialValue" json:"InitialValue"`
  Replace bool `thrift:"Replace,3" db:"Replace" json:"Replace"`
}

func NewCAddCommand() *CAddCommand {
  return &CAddCommand{}
}


func (p *CAddCommand) GetName() string {
  return p.Name
}

func (p *CAddCommand) GetInitialValue() int64 {
  return p.InitialValue
}

func (p *CAddCommand) GetReplace() bool {
  return p.Replace
}
func (p *CAddCommand) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CAddCommand)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Name = v
}
  return nil
}

func (p *CAddCommand)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.InitialValue = v
}
  return nil
}

func (p *CAddCommand)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Replace = v
}
  return nil
}

func (p *CAddCommand) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "CAddCommand"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CAddCommand) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "Name", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:Name: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Name)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.Name (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:Name: ", p), err) }
  return err
}

func (p *CAddCommand) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "InitialValue", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:InitialValue: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.InitialValue)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.InitialValue (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:InitialValue: ", p), err) }
  return err
}

func (p *CAddCommand) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "Replace", thrift.BOOL, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:Replace: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.Replace)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.Replace (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:Replace: ", p), err) }
  return err
}

func (p *CAddCommand) Equals(other *CAddCommand) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Name != other.Name { return false }
  if p.InitialValue != other.InitialValue { return false }
  if p.Replace != other.Replace { return false }
  return true
}

func (p *CAddCommand) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CAddCommand(%+v)", *p)
}

// Attributes:
//  - Name
//  - Delta
//  - ReturnOld
type CChangeCommand struct {
  Name string `thrift:"Name,1" db:"Name" json:"Name"`
  Delta int64 `thrift:"Delta,2" db:"Delta" json:"Delta"`
  ReturnOld bool `thrift:"ReturnOld,3" db:"ReturnOld" json:"ReturnOld"`
}

func NewCChangeCommand() *CChangeCommand {
  return &CChangeCommand{}
}


func (p *CChangeCommand) GetName() string {
  return p.Name
}

func (p *CChangeCommand) GetDelta() int64 {
  return p.Delta
}

func (p *CChangeCommand) GetReturnOld() bool {
  return p.ReturnOld
}
func (p *CChangeCommand) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CChangeCommand)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Name = v
}
  return nil
}

func (p *CChangeCommand)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Delta = v
}
  return nil
}

func (p *CChangeCommand)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.ReturnOld = v
}
  return nil
}

func (p *CChangeCommand) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "CChangeCommand"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CChangeCommand) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "Name", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:Name: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Name)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.Name (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:Name: ", p), err) }
  return err
}

func (p *CChangeCommand) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "Delta", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:Delta: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.Delta)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.Delta (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:Delta: ", p), err) }
  return err
}

func (p *CChangeCommand) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "ReturnOld", thrift.BOOL, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:ReturnOld: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.ReturnOld)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.ReturnOld (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:ReturnOld: ", p), err) }
  return err
}

func (p *CChangeCommand) Equals(other *CChangeCommand) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Name != other.Name { return false }
  if p.Delta != other.Delta { return false }
  if p.ReturnOld != other.ReturnOld { return false }
  return true
}

func (p *CChangeCommand) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CChangeCommand(%+v)", *p)
}

// Attributes:
//  - Name
//  - Expected
//  - UpdVal
type CASCommand struct {
  Name string `thrift:"Name,1" db:"Name" json:"Name"`
  Expected int64 `thrift:"Expected,2" db:"Expected" json:"Expected"`
  UpdVal int64 `thrift:"UpdVal,3" db:"UpdVal" json:"UpdVal"`
}

func NewCASCommand() *CASCommand {
  return &CASCommand{}
}


func (p *CASCommand) GetName() string {
  return p.Name
}

func (p *CASCommand) GetExpected() int64 {
  return p.Expected
}

func (p *CASCommand) GetUpdVal() int64 {
  return p.UpdVal
}
func (p *CASCommand) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CASCommand)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Name = v
}
  return nil
}

func (p *CASCommand)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Expected = v
}
  return nil
}

func (p *CASCommand)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.UpdVal = v
}
  return nil
}

func (p *CASCommand) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "CASCommand"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CASCommand) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "Name", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:Name: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Name)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.Name (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:Name: ", p), err) }
  return err
}

func (p *CASCommand) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "Expected", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:Expected: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.Expected)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.Expected (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:Expected: ", p), err) }
  return err
}

func (p *CASCommand) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "UpdVal", thrift.I64, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:UpdVal: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.UpdVal)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.UpdVal (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:UpdVal: ", p), err) }
  return err
}

func (p *CASCommand) Equals(other *CASCommand) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Name != other.Name { return false }
  if p.Expected != other.Expected { return false }
  if p.UpdVal != other.UpdVal { return false }
  return true
}

func (p *CASCommand) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CASCommand(%+v)", *p)
}

// Attributes:
//  - Name
//  - Expiry
type HLogCreateCmd struct {
  Name string `thrift:"Name,1" db:"Name" json:"Name"`
  Expiry int64 `thrift:"Expiry,2" db:"Expiry" json:"Expiry"`
}

func NewHLogCreateCmd() *HLogCreateCmd {
  return &HLogCreateCmd{}
}


func (p *HLogCreateCmd) GetName() string {
  return p.Name
}

func (p *HLogCreateCmd) GetExpiry() int64 {
  return p.Expiry
}
func (p *HLogCreateCmd) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *HLogCreateCmd)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Name = v
}
  return nil
}

func (p *HLogCreateCmd)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Expiry = v
}
  return nil
}

func (p *HLogCreateCmd) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "HLogCreateCmd"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *HLogCreateCmd) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "Name", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:Name: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Name)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.Name (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:Name: ", p), err) }
  return err
}

func (p *HLogCreateCmd) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "Expiry", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:Expiry: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.Expiry)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.Expiry (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:Expiry: ", p), err) }
  return err
}

func (p *HLogCreateCmd) Equals(other *HLogCreateCmd) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Name != other.Name { return false }
  if p.Expiry != other.Expiry { return false }
  return true
}

func (p *HLogCreateCmd) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("HLogCreateCmd(%+v)", *p)
}

// Attributes:
//  - Key
//  - Data
type HLogAddCmd struct {
  Key string `thrift:"Key,1" db:"Key" json:"Key"`
  Data []byte `thrift:"Data,2" db:"Data" json:"Data"`
}

func NewHLogAddCmd() *HLogAddCmd {
  return &HLogAddCmd{}
}


func (p *HLogAddCmd) GetKey() string {
  return p.Key
}

func (p *HLogAddCmd) GetData() []byte {
  return p.Data
}
func (p *HLogAddCmd) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *HLogAddCmd)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Key = v
}
  return nil
}

func (p *HLogAddCmd)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Data = v
}
  return nil
}

func (p *HLogAddCmd) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "HLogAddCmd"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *HLogAddCmd) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "Key", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:Key: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Key)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.Key (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:Key: ", p), err) }
  return err
}

func (p *HLogAddCmd) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "Data", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:Data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Data); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.Data (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:Data: ", p), err) }
  return err
}

func (p *HLogAddCmd) Equals(other *HLogAddCmd) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Key != other.Key { return false }
  if bytes.Compare(p.Data, other.Data) != 0 { return false }
  return true
}

func (p *HLogAddCmd) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("HLogAddCmd(%+v)", *p)
}

// Attributes:
//  - Key
//  - Expiry
//  - Value
//  - Stat
type HLogStatus struct {
  Key string `thrift:"Key,1" db:"Key" json:"Key"`
  Expiry *int64 `thrift:"Expiry,2" db:"Expiry" json:"Expiry,omitempty"`
  Value *int64 `thrift:"Value,3" db:"Value" json:"Value,omitempty"`
  Stat Status `thrift:"Stat,4" db:"Stat" json:"Stat"`
}

func NewHLogStatus() *HLogStatus {
  return &HLogStatus{}
}


func (p *HLogStatus) GetKey() string {
  return p.Key
}
var HLogStatus_Expiry_DEFAULT int64
func (p *HLogStatus) GetExpiry() int64 {
  if !p.IsSetExpiry() {
    return HLogStatus_Expiry_DEFAULT
  }
return *p.Expiry
}
var HLogStatus_Value_DEFAULT int64
func (p *HLogStatus) GetValue() int64 {
  if !p.IsSetValue() {
    return HLogStatus_Value_DEFAULT
  }
return *p.Value
}

func (p *HLogStatus) GetStat() Status {
  return p.Stat
}
func (p *HLogStatus) IsSetExpiry() bool {
  return p.Expiry != nil
}

func (p *HLogStatus) IsSetValue() bool {
  return p.Value != nil
}

func (p *HLogStatus) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *HLogStatus)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Key = v
}
  return nil
}

func (p *HLogStatus)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Expiry = &v
}
  return nil
}

func (p *HLogStatus)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Value = &v
}
  return nil
}

func (p *HLogStatus)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  temp := Status(v)
  p.Stat = temp
}
  return nil
}

func (p *HLogStatus) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "HLogStatus"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *HLogStatus) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "Key", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:Key: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Key)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.Key (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:Key: ", p), err) }
  return err
}

func (p *HLogStatus) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetExpiry() {
    if err := oprot.WriteFieldBegin(ctx, "Expiry", thrift.I64, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:Expiry: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.Expiry)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.Expiry (2) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:Expiry: ", p), err) }
  }
  return err
}

func (p *HLogStatus) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetValue() {
    if err := oprot.WriteFieldBegin(ctx, "Value", thrift.I64, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:Value: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.Value)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.Value (3) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:Value: ", p), err) }
  }
  return err
}

func (p *HLogStatus) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "Stat", thrift.I32, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:Stat: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Stat)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.Stat (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:Stat: ", p), err) }
  return err
}

func (p *HLogStatus) Equals(other *HLogStatus) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Key != other.Key { return false }
  if p.Expiry != other.Expiry {
    if p.Expiry == nil || other.Expiry == nil {
      return false
    }
    if (*p.Expiry) != (*other.Expiry) { return false }
  }
  if p.Value != other.Value {
    if p.Value == nil || other.Value == nil {
      return false
    }
    if (*p.Value) != (*other.Value) { return false }
  }
  if p.Stat != other.Stat { return false }
  return true
}

func (p *HLogStatus) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("HLogStatus(%+v)", *p)
}

type GeetcacheService interface {
  // Parameters:
  //  - Put
  Put(ctx context.Context, put *PutCommand) (_r Status, _err error)
  // Parameters:
  //  - ListPut
  ListPut(ctx context.Context, listPut *ListPutCommand) (_r Status, _err error)
  // Parameters:
  //  - LPop
  ListPop(ctx context.Context, lPop *ListGPCommand) (_r *ListGPResponse, _err error)
  // Parameters:
  //  - LGet
  ListGet(ctx context.Context, lGet *ListGPCommand) (_r *ListGPResponse, _err error)
  // Parameters:
  //  - Key
  ListLen(ctx context.Context, key string) (_r *ListLenResponse, _err error)
  // Parameters:
  //  - Key
  Get(ctx context.Context, key string) (_r *GetResponse, _err error)
  // Parameters:
  //  - Key
  Delete(ctx context.Context, key string) (_r *DelResponse, _err error)
  // Parameters:
  //  - Key
  DeleteList(ctx context.Context, key string) (_r *DelResponse, _err error)
  Leader(ctx context.Context) (_r *LeaderResponse, _err error)
  Peers(ctx context.Context) (_r *PeersResponse, _err error)
  // Parameters:
  //  - Counter
  AddCounter(ctx context.Context, counter *CAddCommand) (_r Status, _err error)
  // Parameters:
  //  - CounterName
  DeleteCounter(ctx context.Context, counterName string) (_r Status, _err error)
  // Parameters:
  //  - Counter
  Increament(ctx context.Context, counter *CChangeCommand) (_r *CStatus, _err error)
  // Parameters:
  //  - Counter
  Decrement(ctx context.Context, counter *CChangeCommand) (_r *CStatus, _err error)
  // Parameters:
  //  - CounterName
  GetCounterValue(ctx context.Context, counterName string) (_r *CStatus, _err error)
  // Parameters:
  //  - Cas
  CompSwap(ctx context.Context, cas *CASCommand) (_r Status, _err error)
  // Parameters:
  //  - Hlcmd
  HLogCreate(ctx context.Context, hlcmd *HLogCreateCmd) (_r *HLogStatus, _err error)
  // Parameters:
  //  - Key
  HLogDelete(ctx context.Context, key string) (_r *HLogStatus, _err error)
  // Parameters:
  //  - Key
  HLogCardinality(ctx context.Context, key string) (_r *HLogStatus, _err error)
  // Parameters:
  //  - Hladd
  HLogAdd(ctx context.Context, hladd *HLogAddCmd) (_r *HLogStatus, _err error)
}

type GeetcacheServiceClient struct {
  c thrift.TClient
  meta thrift.ResponseMeta
}

func NewGeetcacheServiceClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *GeetcacheServiceClient {
  return &GeetcacheServiceClient{
    c: thrift.NewTStandardClient(f.GetProtocol(t), f.GetProtocol(t)),
  }
}

func NewGeetcacheServiceClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *GeetcacheServiceClient {
  return &GeetcacheServiceClient{
    c: thrift.NewTStandardClient(iprot, oprot),
  }
}

func NewGeetcacheServiceClient(c thrift.TClient) *GeetcacheServiceClient {
  return &GeetcacheServiceClient{
    c: c,
  }
}

func (p *GeetcacheServiceClient) Client_() thrift.TClient {
  return p.c
}

func (p *GeetcacheServiceClient) LastResponseMeta_() thrift.ResponseMeta {
  return p.meta
}

func (p *GeetcacheServiceClient) SetLastResponseMeta_(meta thrift.ResponseMeta) {
  p.meta = meta
}

// Parameters:
//  - Put
func (p *GeetcacheServiceClient) Put(ctx context.Context, put *PutCommand) (_r Status, _err error) {
  var _args6 GeetcacheServicePutArgs
  _args6.Put = put
  var _result8 GeetcacheServicePutResult
  var _meta7 thrift.ResponseMeta
  _meta7, _err = p.Client_().Call(ctx, "Put", &_args6, &_result8)
  p.SetLastResponseMeta_(_meta7)
  if _err != nil {
    return
  }
  return _result8.GetSuccess(), nil
}

// Parameters:
//  - ListPut
func (p *GeetcacheServiceClient) ListPut(ctx context.Context, listPut *ListPutCommand) (_r Status, _err error) {
  var _args9 GeetcacheServiceListPutArgs
  _args9.ListPut = listPut
  var _result11 GeetcacheServiceListPutResult
  var _meta10 thrift.ResponseMeta
  _meta10, _err = p.Client_().Call(ctx, "ListPut", &_args9, &_result11)
  p.SetLastResponseMeta_(_meta10)
  if _err != nil {
    return
  }
  return _result11.GetSuccess(), nil
}

// Parameters:
//  - LPop
func (p *GeetcacheServiceClient) ListPop(ctx context.Context, lPop *ListGPCommand) (_r *ListGPResponse, _err error) {
  var _args12 GeetcacheServiceListPopArgs
  _args12.LPop = lPop
  var _result14 GeetcacheServiceListPopResult
  var _meta13 thrift.ResponseMeta
  _meta13, _err = p.Client_().Call(ctx, "ListPop", &_args12, &_result14)
  p.SetLastResponseMeta_(_meta13)
  if _err != nil {
    return
  }
  if _ret15 := _result14.GetSuccess(); _ret15 != nil {
    return _ret15, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "ListPop failed: unknown result")
}

// Parameters:
//  - LGet
func (p *GeetcacheServiceClient) ListGet(ctx context.Context, lGet *ListGPCommand) (_r *ListGPResponse, _err error) {
  var _args16 GeetcacheServiceListGetArgs
  _args16.LGet = lGet
  var _result18 GeetcacheServiceListGetResult
  var _meta17 thrift.ResponseMeta
  _meta17, _err = p.Client_().Call(ctx, "ListGet", &_args16, &_result18)
  p.SetLastResponseMeta_(_meta17)
  if _err != nil {
    return
  }
  if _ret19 := _result18.GetSuccess(); _ret19 != nil {
    return _ret19, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "ListGet failed: unknown result")
}

// Parameters:
//  - Key
func (p *GeetcacheServiceClient) ListLen(ctx context.Context, key string) (_r *ListLenResponse, _err error) {
  var _args20 GeetcacheServiceListLenArgs
  _args20.Key = key
  var _result22 GeetcacheServiceListLenResult
  var _meta21 thrift.ResponseMeta
  _meta21, _err = p.Client_().Call(ctx, "ListLen", &_args20, &_result22)
  p.SetLastResponseMeta_(_meta21)
  if _err != nil {
    return
  }
  if _ret23 := _result22.GetSuccess(); _ret23 != nil {
    return _ret23, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "ListLen failed: unknown result")
}

// Parameters:
//  - Key
func (p *GeetcacheServiceClient) Get(ctx context.Context, key string) (_r *GetResponse, _err error) {
  var _args24 GeetcacheServiceGetArgs
  _args24.Key = key
  var _result26 GeetcacheServiceGetResult
  var _meta25 thrift.ResponseMeta
  _meta25, _err = p.Client_().Call(ctx, "Get", &_args24, &_result26)
  p.SetLastResponseMeta_(_meta25)
  if _err != nil {
    return
  }
  if _ret27 := _result26.GetSuccess(); _ret27 != nil {
    return _ret27, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "Get failed: unknown result")
}

// Parameters:
//  - Key
func (p *GeetcacheServiceClient) Delete(ctx context.Context, key string) (_r *DelResponse, _err error) {
  var _args28 GeetcacheServiceDeleteArgs
  _args28.Key = key
  var _result30 GeetcacheServiceDeleteResult
  var _meta29 thrift.ResponseMeta
  _meta29, _err = p.Client_().Call(ctx, "Delete", &_args28, &_result30)
  p.SetLastResponseMeta_(_meta29)
  if _err != nil {
    return
  }
  if _ret31 := _result30.GetSuccess(); _ret31 != nil {
    return _ret31, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "Delete failed: unknown result")
}

// Parameters:
//  - Key
func (p *GeetcacheServiceClient) DeleteList(ctx context.Context, key string) (_r *DelResponse, _err error) {
  var _args32 GeetcacheServiceDeleteListArgs
  _args32.Key = key
  var _result34 GeetcacheServiceDeleteListResult
  var _meta33 thrift.ResponseMeta
  _meta33, _err = p.Client_().Call(ctx, "DeleteList", &_args32, &_result34)
  p.SetLastResponseMeta_(_meta33)
  if _err != nil {
    return
  }
  if _ret35 := _result34.GetSuccess(); _ret35 != nil {
    return _ret35, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "DeleteList failed: unknown result")
}

func (p *GeetcacheServiceClient) Leader(ctx context.Context) (_r *LeaderResponse, _err error) {
  var _args36 GeetcacheServiceLeaderArgs
  var _result38 GeetcacheServiceLeaderResult
  var _meta37 thrift.ResponseMeta
  _meta37, _err = p.Client_().Call(ctx, "Leader", &_args36, &_result38)
  p.SetLastResponseMeta_(_meta37)
  if _err != nil {
    return
  }
  if _ret39 := _result38.GetSuccess(); _ret39 != nil {
    return _ret39, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "Leader failed: unknown result")
}

func (p *GeetcacheServiceClient) Peers(ctx context.Context) (_r *PeersResponse, _err error) {
  var _args40 GeetcacheServicePeersArgs
  var _result42 GeetcacheServicePeersResult
  var _meta41 thrift.ResponseMeta
  _meta41, _err = p.Client_().Call(ctx, "Peers", &_args40, &_result42)
  p.SetLastResponseMeta_(_meta41)
  if _err != nil {
    return
  }
  if _ret43 := _result42.GetSuccess(); _ret43 != nil {
    return _ret43, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "Peers failed: unknown result")
}

// Parameters:
//  - Counter
func (p *GeetcacheServiceClient) AddCounter(ctx context.Context, counter *CAddCommand) (_r Status, _err error) {
  var _args44 GeetcacheServiceAddCounterArgs
  _args44.Counter = counter
  var _result46 GeetcacheServiceAddCounterResult
  var _meta45 thrift.ResponseMeta
  _meta45, _err = p.Client_().Call(ctx, "AddCounter", &_args44, &_result46)
  p.SetLastResponseMeta_(_meta45)
  if _err != nil {
    return
  }
  return _result46.GetSuccess(), nil
}

// Parameters:
//  - CounterName
func (p *GeetcacheServiceClient) DeleteCounter(ctx context.Context, counterName string) (_r Status, _err error) {
  var _args47 GeetcacheServiceDeleteCounterArgs
  _args47.CounterName = counterName
  var _result49 GeetcacheServiceDeleteCounterResult
  var _meta48 thrift.ResponseMeta
  _meta48, _err = p.Client_().Call(ctx, "DeleteCounter", &_args47, &_result49)
  p.SetLastResponseMeta_(_meta48)
  if _err != nil {
    return
  }
  return _result49.GetSuccess(), nil
}

// Parameters:
//  - Counter
func (p *GeetcacheServiceClient) Increament(ctx context.Context, counter *CChangeCommand) (_r *CStatus, _err error) {
  var _args50 GeetcacheServiceIncreamentArgs
  _args50.Counter = counter
  var _result52 GeetcacheServiceIncreamentResult
  var _meta51 thrift.ResponseMeta
  _meta51, _err = p.Client_().Call(ctx, "Increament", &_args50, &_result52)
  p.SetLastResponseMeta_(_meta51)
  if _err != nil {
    return
  }
  if _ret53 := _result52.GetSuccess(); _ret53 != nil {
    return _ret53, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "Increament failed: unknown result")
}

// Parameters:
//  - Counter
func (p *GeetcacheServiceClient) Decrement(ctx context.Context, counter *CChangeCommand) (_r *CStatus, _err error) {
  var _args54 GeetcacheServiceDecrementArgs
  _args54.Counter = counter
  var _result56 GeetcacheServiceDecrementResult
  var _meta55 thrift.ResponseMeta
  _meta55, _err = p.Client_().Call(ctx, "Decrement", &_args54, &_result56)
  p.SetLastResponseMeta_(_meta55)
  if _err != nil {
    return
  }
  if _ret57 := _result56.GetSuccess(); _ret57 != nil {
    return _ret57, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "Decrement failed: unknown result")
}

// Parameters:
//  - CounterName
func (p *GeetcacheServiceClient) GetCounterValue(ctx context.Context, counterName string) (_r *CStatus, _err error) {
  var _args58 GeetcacheServiceGetCounterValueArgs
  _args58.CounterName = counterName
  var _result60 GeetcacheServiceGetCounterValueResult
  var _meta59 thrift.ResponseMeta
  _meta59, _err = p.Client_().Call(ctx, "GetCounterValue", &_args58, &_result60)
  p.SetLastResponseMeta_(_meta59)
  if _err != nil {
    return
  }
  if _ret61 := _result60.GetSuccess(); _ret61 != nil {
    return _ret61, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "GetCounterValue failed: unknown result")
}

// Parameters:
//  - Cas
func (p *GeetcacheServiceClient) CompSwap(ctx context.Context, cas *CASCommand) (_r Status, _err error) {
  var _args62 GeetcacheServiceCompSwapArgs
  _args62.Cas = cas
  var _result64 GeetcacheServiceCompSwapResult
  var _meta63 thrift.ResponseMeta
  _meta63, _err = p.Client_().Call(ctx, "CompSwap", &_args62, &_result64)
  p.SetLastResponseMeta_(_meta63)
  if _err != nil {
    return
  }
  return _result64.GetSuccess(), nil
}

// Parameters:
//  - Hlcmd
func (p *GeetcacheServiceClient) HLogCreate(ctx context.Context, hlcmd *HLogCreateCmd) (_r *HLogStatus, _err error) {
  var _args65 GeetcacheServiceHLogCreateArgs
  _args65.Hlcmd = hlcmd
  var _result67 GeetcacheServiceHLogCreateResult
  var _meta66 thrift.ResponseMeta
  _meta66, _err = p.Client_().Call(ctx, "HLogCreate", &_args65, &_result67)
  p.SetLastResponseMeta_(_meta66)
  if _err != nil {
    return
  }
  if _ret68 := _result67.GetSuccess(); _ret68 != nil {
    return _ret68, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "HLogCreate failed: unknown result")
}

// Parameters:
//  - Key
func (p *GeetcacheServiceClient) HLogDelete(ctx context.Context, key string) (_r *HLogStatus, _err error) {
  var _args69 GeetcacheServiceHLogDeleteArgs
  _args69.Key = key
  var _result71 GeetcacheServiceHLogDeleteResult
  var _meta70 thrift.ResponseMeta
  _meta70, _err = p.Client_().Call(ctx, "HLogDelete", &_args69, &_result71)
  p.SetLastResponseMeta_(_meta70)
  if _err != nil {
    return
  }
  if _ret72 := _result71.GetSuccess(); _ret72 != nil {
    return _ret72, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "HLogDelete failed: unknown result")
}

// Parameters:
//  - Key
func (p *GeetcacheServiceClient) HLogCardinality(ctx context.Context, key string) (_r *HLogStatus, _err error) {
  var _args73 GeetcacheServiceHLogCardinalityArgs
  _args73.Key = key
  var _result75 GeetcacheServiceHLogCardinalityResult
  var _meta74 thrift.ResponseMeta
  _meta74, _err = p.Client_().Call(ctx, "HLogCardinality", &_args73, &_result75)
  p.SetLastResponseMeta_(_meta74)
  if _err != nil {
    return
  }
  if _ret76 := _result75.GetSuccess(); _ret76 != nil {
    return _ret76, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "HLogCardinality failed: unknown result")
}

// Parameters:
//  - Hladd
func (p *GeetcacheServiceClient) HLogAdd(ctx context.Context, hladd *HLogAddCmd) (_r *HLogStatus, _err error) {
  var _args77 GeetcacheServiceHLogAddArgs
  _args77.Hladd = hladd
  var _result79 GeetcacheServiceHLogAddResult
  var _meta78 thrift.ResponseMeta
  _meta78, _err = p.Client_().Call(ctx, "HLogAdd", &_args77, &_result79)
  p.SetLastResponseMeta_(_meta78)
  if _err != nil {
    return
  }
  if _ret80 := _result79.GetSuccess(); _ret80 != nil {
    return _ret80, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "HLogAdd failed: unknown result")
}

type GeetcacheServiceProcessor struct {
  processorMap map[string]thrift.TProcessorFunction
  handler GeetcacheService
}

func (p *GeetcacheServiceProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
  p.processorMap[key] = processor
}

func (p *GeetcacheServiceProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
  processor, ok = p.processorMap[key]
  return processor, ok
}

func (p *GeetcacheServiceProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
  return p.processorMap
}

func NewGeetcacheServiceProcessor(handler GeetcacheService) *GeetcacheServiceProcessor {

  self81 := &GeetcacheServiceProcessor{handler:handler, processorMap:make(map[string]thrift.TProcessorFunction)}
  self81.processorMap["Put"] = &geetcacheServiceProcessorPut{handler:handler}
  self81.processorMap["ListPut"] = &geetcacheServiceProcessorListPut{handler:handler}
  self81.processorMap["ListPop"] = &geetcacheServiceProcessorListPop{handler:handler}
  self81.processorMap["ListGet"] = &geetcacheServiceProcessorListGet{handler:handler}
  self81.processorMap["ListLen"] = &geetcacheServiceProcessorListLen{handler:handler}
  self81.processorMap["Get"] = &geetcacheServiceProcessorGet{handler:handler}
  self81.processorMap["Delete"] = &geetcacheServiceProcessorDelete{handler:handler}
  self81.processorMap["DeleteList"] = &geetcacheServiceProcessorDeleteList{handler:handler}
  self81.processorMap["Leader"] = &geetcacheServiceProcessorLeader{handler:handler}
  self81.processorMap["Peers"] = &geetcacheServiceProcessorPeers{handler:handler}
  self81.processorMap["AddCounter"] = &geetcacheServiceProcessorAddCounter{handler:handler}
  self81.processorMap["DeleteCounter"] = &geetcacheServiceProcessorDeleteCounter{handler:handler}
  self81.processorMap["Increament"] = &geetcacheServiceProcessorIncreament{handler:handler}
  self81.processorMap["Decrement"] = &geetcacheServiceProcessorDecrement{handler:handler}
  self81.processorMap["GetCounterValue"] = &geetcacheServiceProcessorGetCounterValue{handler:handler}
  self81.processorMap["CompSwap"] = &geetcacheServiceProcessorCompSwap{handler:handler}
  self81.processorMap["HLogCreate"] = &geetcacheServiceProcessorHLogCreate{handler:handler}
  self81.processorMap["HLogDelete"] = &geetcacheServiceProcessorHLogDelete{handler:handler}
  self81.processorMap["HLogCardinality"] = &geetcacheServiceProcessorHLogCardinality{handler:handler}
  self81.processorMap["HLogAdd"] = &geetcacheServiceProcessorHLogAdd{handler:handler}
return self81
}

func (p *GeetcacheServiceProcessor) Process(ctx context.Context, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  name, _, seqId, err2 := iprot.ReadMessageBegin(ctx)
  if err2 != nil { return false, thrift.WrapTException(err2) }
  if processor, ok := p.GetProcessorFunction(name); ok {
    return processor.Process(ctx, seqId, iprot, oprot)
  }
  iprot.Skip(ctx, thrift.STRUCT)
  iprot.ReadMessageEnd(ctx)
  x82 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function " + name)
  oprot.WriteMessageBegin(ctx, name, thrift.EXCEPTION, seqId)
  x82.Write(ctx, oprot)
  oprot.WriteMessageEnd(ctx)
  oprot.Flush(ctx)
  return false, x82

}

type geetcacheServiceProcessorPut struct {
  handler GeetcacheService
}

func (p *geetcacheServiceProcessorPut) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := GeetcacheServicePutArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "Put", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := GeetcacheServicePutResult{}
  var retval Status
  if retval, err2 = p.handler.Put(ctx, args.Put); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing Put: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "Put", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "Put", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type geetcacheServiceProcessorListPut struct {
  handler GeetcacheService
}

func (p *geetcacheServiceProcessorListPut) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := GeetcacheServiceListPutArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "ListPut", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := GeetcacheServiceListPutResult{}
  var retval Status
  if retval, err2 = p.handler.ListPut(ctx, args.ListPut); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing ListPut: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "ListPut", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "ListPut", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type geetcacheServiceProcessorListPop struct {
  handler GeetcacheService
}

func (p *geetcacheServiceProcessorListPop) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := GeetcacheServiceListPopArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "ListPop", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := GeetcacheServiceListPopResult{}
  var retval *ListGPResponse
  if retval, err2 = p.handler.ListPop(ctx, args.LPop); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing ListPop: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "ListPop", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "ListPop", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type geetcacheServiceProcessorListGet struct {
  handler GeetcacheService
}

func (p *geetcacheServiceProcessorListGet) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := GeetcacheServiceListGetArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "ListGet", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := GeetcacheServiceListGetResult{}
  var retval *ListGPResponse
  if retval, err2 = p.handler.ListGet(ctx, args.LGet); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing ListGet: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "ListGet", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "ListGet", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type geetcacheServiceProcessorListLen struct {
  handler GeetcacheService
}

func (p *geetcacheServiceProcessorListLen) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := GeetcacheServiceListLenArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "ListLen", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := GeetcacheServiceListLenResult{}
  var retval *ListLenResponse
  if retval, err2 = p.handler.ListLen(ctx, args.Key); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing ListLen: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "ListLen", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "ListLen", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type geetcacheServiceProcessorGet struct {
  handler GeetcacheService
}

func (p *geetcacheServiceProcessorGet) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := GeetcacheServiceGetArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "Get", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := GeetcacheServiceGetResult{}
  var retval *GetResponse
  if retval, err2 = p.handler.Get(ctx, args.Key); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing Get: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "Get", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "Get", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type geetcacheServiceProcessorDelete struct {
  handler GeetcacheService
}

func (p *geetcacheServiceProcessorDelete) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := GeetcacheServiceDeleteArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "Delete", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := GeetcacheServiceDeleteResult{}
  var retval *DelResponse
  if retval, err2 = p.handler.Delete(ctx, args.Key); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing Delete: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "Delete", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "Delete", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type geetcacheServiceProcessorDeleteList struct {
  handler GeetcacheService
}

func (p *geetcacheServiceProcessorDeleteList) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := GeetcacheServiceDeleteListArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "DeleteList", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := GeetcacheServiceDeleteListResult{}
  var retval *DelResponse
  if retval, err2 = p.handler.DeleteList(ctx, args.Key); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing DeleteList: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "DeleteList", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "DeleteList", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type geetcacheServiceProcessorLeader struct {
  handler GeetcacheService
}

func (p *geetcacheServiceProcessorLeader) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := GeetcacheServiceLeaderArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "Leader", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := GeetcacheServiceLeaderResult{}
  var retval *LeaderResponse
  if retval, err2 = p.handler.Leader(ctx); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing Leader: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "Leader", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "Leader", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type geetcacheServiceProcessorPeers struct {
  handler GeetcacheService
}

func (p *geetcacheServiceProcessorPeers) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := GeetcacheServicePeersArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "Peers", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := GeetcacheServicePeersResult{}
  var retval *PeersResponse
  if retval, err2 = p.handler.Peers(ctx); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing Peers: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "Peers", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "Peers", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type geetcacheServiceProcessorAddCounter struct {
  handler GeetcacheService
}

func (p *geetcacheServiceProcessorAddCounter) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := GeetcacheServiceAddCounterArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "AddCounter", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := GeetcacheServiceAddCounterResult{}
  var retval Status
  if retval, err2 = p.handler.AddCounter(ctx, args.Counter); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing AddCounter: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "AddCounter", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "AddCounter", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type geetcacheServiceProcessorDeleteCounter struct {
  handler GeetcacheService
}

func (p *geetcacheServiceProcessorDeleteCounter) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := GeetcacheServiceDeleteCounterArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "DeleteCounter", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := GeetcacheServiceDeleteCounterResult{}
  var retval Status
  if retval, err2 = p.handler.DeleteCounter(ctx, args.CounterName); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing DeleteCounter: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "DeleteCounter", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "DeleteCounter", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type geetcacheServiceProcessorIncreament struct {
  handler GeetcacheService
}

func (p *geetcacheServiceProcessorIncreament) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := GeetcacheServiceIncreamentArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "Increament", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := GeetcacheServiceIncreamentResult{}
  var retval *CStatus
  if retval, err2 = p.handler.Increament(ctx, args.Counter); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing Increament: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "Increament", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "Increament", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type geetcacheServiceProcessorDecrement struct {
  handler GeetcacheService
}

func (p *geetcacheServiceProcessorDecrement) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := GeetcacheServiceDecrementArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "Decrement", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := GeetcacheServiceDecrementResult{}
  var retval *CStatus
  if retval, err2 = p.handler.Decrement(ctx, args.Counter); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing Decrement: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "Decrement", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "Decrement", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type geetcacheServiceProcessorGetCounterValue struct {
  handler GeetcacheService
}

func (p *geetcacheServiceProcessorGetCounterValue) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := GeetcacheServiceGetCounterValueArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "GetCounterValue", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := GeetcacheServiceGetCounterValueResult{}
  var retval *CStatus
  if retval, err2 = p.handler.GetCounterValue(ctx, args.CounterName); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing GetCounterValue: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "GetCounterValue", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "GetCounterValue", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type geetcacheServiceProcessorCompSwap struct {
  handler GeetcacheService
}

func (p *geetcacheServiceProcessorCompSwap) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := GeetcacheServiceCompSwapArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "CompSwap", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := GeetcacheServiceCompSwapResult{}
  var retval Status
  if retval, err2 = p.handler.CompSwap(ctx, args.Cas); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing CompSwap: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "CompSwap", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "CompSwap", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type geetcacheServiceProcessorHLogCreate struct {
  handler GeetcacheService
}

func (p *geetcacheServiceProcessorHLogCreate) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := GeetcacheServiceHLogCreateArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "HLogCreate", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := GeetcacheServiceHLogCreateResult{}
  var retval *HLogStatus
  if retval, err2 = p.handler.HLogCreate(ctx, args.Hlcmd); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing HLogCreate: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "HLogCreate", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "HLogCreate", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type geetcacheServiceProcessorHLogDelete struct {
  handler GeetcacheService
}

func (p *geetcacheServiceProcessorHLogDelete) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := GeetcacheServiceHLogDeleteArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "HLogDelete", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := GeetcacheServiceHLogDeleteResult{}
  var retval *HLogStatus
  if retval, err2 = p.handler.HLogDelete(ctx, args.Key); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing HLogDelete: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "HLogDelete", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "HLogDelete", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type geetcacheServiceProcessorHLogCardinality struct {
  handler GeetcacheService
}

func (p *geetcacheServiceProcessorHLogCardinality) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := GeetcacheServiceHLogCardinalityArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "HLogCardinality", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := GeetcacheServiceHLogCardinalityResult{}
  var retval *HLogStatus
  if retval, err2 = p.handler.HLogCardinality(ctx, args.Key); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing HLogCardinality: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "HLogCardinality", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "HLogCardinality", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type geetcacheServiceProcessorHLogAdd struct {
  handler GeetcacheService
}

func (p *geetcacheServiceProcessorHLogAdd) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := GeetcacheServiceHLogAddArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "HLogAdd", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := GeetcacheServiceHLogAddResult{}
  var retval *HLogStatus
  if retval, err2 = p.handler.HLogAdd(ctx, args.Hladd); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing HLogAdd: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "HLogAdd", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "HLogAdd", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}


// HELPER FUNCTIONS AND STRUCTURES

// Attributes:
//  - Put
type GeetcacheServicePutArgs struct {
  Put *PutCommand `thrift:"put,1" db:"put" json:"put"`
}

func NewGeetcacheServicePutArgs() *GeetcacheServicePutArgs {
  return &GeetcacheServicePutArgs{}
}

var GeetcacheServicePutArgs_Put_DEFAULT *PutCommand
func (p *GeetcacheServicePutArgs) GetPut() *PutCommand {
  if !p.IsSetPut() {
    return GeetcacheServicePutArgs_Put_DEFAULT
  }
return p.Put
}
func (p *GeetcacheServicePutArgs) IsSetPut() bool {
  return p.Put != nil
}

func (p *GeetcacheServicePutArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *GeetcacheServicePutArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Put = &PutCommand{}
  if err := p.Put.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Put), err)
  }
  return nil
}

func (p *GeetcacheServicePutArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "Put_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *GeetcacheServicePutArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "put", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:put: ", p), err) }
  if err := p.Put.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Put), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:put: ", p), err) }
  return err
}

func (p *GeetcacheServicePutArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("GeetcacheServicePutArgs(%+v)", *p)
}

// Attributes:
//  - Success
type GeetcacheServicePutResult struct {
  Success *Status `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewGeetcacheServicePutResult() *GeetcacheServicePutResult {
  return &GeetcacheServicePutResult{}
}

var GeetcacheServicePutResult_Success_DEFAULT Status
func (p *GeetcacheServicePutResult) GetSuccess() Status {
  if !p.IsSetSuccess() {
    return GeetcacheServicePutResult_Success_DEFAULT
  }
return *p.Success
}
func (p *GeetcacheServicePutResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *GeetcacheServicePutResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *GeetcacheServicePutResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  temp := Status(v)
  p.Success = &temp
}
  return nil
}

func (p *GeetcacheServicePutResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "Put_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *GeetcacheServicePutResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *GeetcacheServicePutResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("GeetcacheServicePutResult(%+v)", *p)
}

// Attributes:
//  - ListPut
type GeetcacheServiceListPutArgs struct {
  ListPut *ListPutCommand `thrift:"listPut,1" db:"listPut" json:"listPut"`
}

func NewGeetcacheServiceListPutArgs() *GeetcacheServiceListPutArgs {
  return &GeetcacheServiceListPutArgs{}
}

var GeetcacheServiceListPutArgs_ListPut_DEFAULT *ListPutCommand
func (p *GeetcacheServiceListPutArgs) GetListPut() *ListPutCommand {
  if !p.IsSetListPut() {
    return GeetcacheServiceListPutArgs_ListPut_DEFAULT
  }
return p.ListPut
}
func (p *GeetcacheServiceListPutArgs) IsSetListPut() bool {
  return p.ListPut != nil
}

func (p *GeetcacheServiceListPutArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *GeetcacheServiceListPutArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.ListPut = &ListPutCommand{
  Append: true,
}
  if err := p.ListPut.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ListPut), err)
  }
  return nil
}

func (p *GeetcacheServiceListPutArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "ListPut_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *GeetcacheServiceListPutArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "listPut", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:listPut: ", p), err) }
  if err := p.ListPut.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ListPut), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:listPut: ", p), err) }
  return err
}

func (p *GeetcacheServiceListPutArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("GeetcacheServiceListPutArgs(%+v)", *p)
}

// Attributes:
//  - Success
type GeetcacheServiceListPutResult struct {
  Success *Status `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewGeetcacheServiceListPutResult() *GeetcacheServiceListPutResult {
  return &GeetcacheServiceListPutResult{}
}

var GeetcacheServiceListPutResult_Success_DEFAULT Status
func (p *GeetcacheServiceListPutResult) GetSuccess() Status {
  if !p.IsSetSuccess() {
    return GeetcacheServiceListPutResult_Success_DEFAULT
  }
return *p.Success
}
func (p *GeetcacheServiceListPutResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *GeetcacheServiceListPutResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *GeetcacheServiceListPutResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  temp := Status(v)
  p.Success = &temp
}
  return nil
}

func (p *GeetcacheServiceListPutResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "ListPut_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *GeetcacheServiceListPutResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *GeetcacheServiceListPutResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("GeetcacheServiceListPutResult(%+v)", *p)
}

// Attributes:
//  - LPop
type GeetcacheServiceListPopArgs struct {
  LPop *ListGPCommand `thrift:"lPop,1" db:"lPop" json:"lPop"`
}

func NewGeetcacheServiceListPopArgs() *GeetcacheServiceListPopArgs {
  return &GeetcacheServiceListPopArgs{}
}

var GeetcacheServiceListPopArgs_LPop_DEFAULT *ListGPCommand
func (p *GeetcacheServiceListPopArgs) GetLPop() *ListGPCommand {
  if !p.IsSetLPop() {
    return GeetcacheServiceListPopArgs_LPop_DEFAULT
  }
return p.LPop
}
func (p *GeetcacheServiceListPopArgs) IsSetLPop() bool {
  return p.LPop != nil
}

func (p *GeetcacheServiceListPopArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *GeetcacheServiceListPopArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.LPop = &ListGPCommand{
  MaxCount: 1,

  Front: true,
}
  if err := p.LPop.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.LPop), err)
  }
  return nil
}

func (p *GeetcacheServiceListPopArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "ListPop_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *GeetcacheServiceListPopArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "lPop", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:lPop: ", p), err) }
  if err := p.LPop.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.LPop), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:lPop: ", p), err) }
  return err
}

func (p *GeetcacheServiceListPopArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("GeetcacheServiceListPopArgs(%+v)", *p)
}

// Attributes:
//  - Success
type GeetcacheServiceListPopResult struct {
  Success *ListGPResponse `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewGeetcacheServiceListPopResult() *GeetcacheServiceListPopResult {
  return &GeetcacheServiceListPopResult{}
}

var GeetcacheServiceListPopResult_Success_DEFAULT *ListGPResponse
func (p *GeetcacheServiceListPopResult) GetSuccess() *ListGPResponse {
  if !p.IsSetSuccess() {
    return GeetcacheServiceListPopResult_Success_DEFAULT
  }
return p.Success
}
func (p *GeetcacheServiceListPopResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *GeetcacheServiceListPopResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *GeetcacheServiceListPopResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &ListGPResponse{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *GeetcacheServiceListPopResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "ListPop_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *GeetcacheServiceListPopResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *GeetcacheServiceListPopResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("GeetcacheServiceListPopResult(%+v)", *p)
}

// Attributes:
//  - LGet
type GeetcacheServiceListGetArgs struct {
  LGet *ListGPCommand `thrift:"lGet,1" db:"lGet" json:"lGet"`
}

func NewGeetcacheServiceListGetArgs() *GeetcacheServiceListGetArgs {
  return &GeetcacheServiceListGetArgs{}
}

var GeetcacheServiceListGetArgs_LGet_DEFAULT *ListGPCommand
func (p *GeetcacheServiceListGetArgs) GetLGet() *ListGPCommand {
  if !p.IsSetLGet() {
    return GeetcacheServiceListGetArgs_LGet_DEFAULT
  }
return p.LGet
}
func (p *GeetcacheServiceListGetArgs) IsSetLGet() bool {
  return p.LGet != nil
}

func (p *GeetcacheServiceListGetArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *GeetcacheServiceListGetArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.LGet = &ListGPCommand{
  MaxCount: 1,

  Front: true,
}
  if err := p.LGet.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.LGet), err)
  }
  return nil
}

func (p *GeetcacheServiceListGetArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "ListGet_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *GeetcacheServiceListGetArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "lGet", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:lGet: ", p), err) }
  if err := p.LGet.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.LGet), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:lGet: ", p), err) }
  return err
}

func (p *GeetcacheServiceListGetArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("GeetcacheServiceListGetArgs(%+v)", *p)
}

// Attributes:
//  - Success
type GeetcacheServiceListGetResult struct {
  Success *ListGPResponse `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewGeetcacheServiceListGetResult() *GeetcacheServiceListGetResult {
  return &GeetcacheServiceListGetResult{}
}

var GeetcacheServiceListGetResult_Success_DEFAULT *ListGPResponse
func (p *GeetcacheServiceListGetResult) GetSuccess() *ListGPResponse {
  if !p.IsSetSuccess() {
    return GeetcacheServiceListGetResult_Success_DEFAULT
  }
return p.Success
}
func (p *GeetcacheServiceListGetResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *GeetcacheServiceListGetResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *GeetcacheServiceListGetResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &ListGPResponse{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *GeetcacheServiceListGetResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "ListGet_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *GeetcacheServiceListGetResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *GeetcacheServiceListGetResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("GeetcacheServiceListGetResult(%+v)", *p)
}

// Attributes:
//  - Key
type GeetcacheServiceListLenArgs struct {
  Key string `thrift:"key,1" db:"key" json:"key"`
}

func NewGeetcacheServiceListLenArgs() *GeetcacheServiceListLenArgs {
  return &GeetcacheServiceListLenArgs{}
}


func (p *GeetcacheServiceListLenArgs) GetKey() string {
  return p.Key
}
func (p *GeetcacheServiceListLenArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *GeetcacheServiceListLenArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Key = v
}
  return nil
}

func (p *GeetcacheServiceListLenArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "ListLen_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *GeetcacheServiceListLenArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "key", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:key: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Key)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.key (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:key: ", p), err) }
  return err
}

func (p *GeetcacheServiceListLenArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("GeetcacheServiceListLenArgs(%+v)", *p)
}

// Attributes:
//  - Success
type GeetcacheServiceListLenResult struct {
  Success *ListLenResponse `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewGeetcacheServiceListLenResult() *GeetcacheServiceListLenResult {
  return &GeetcacheServiceListLenResult{}
}

var GeetcacheServiceListLenResult_Success_DEFAULT *ListLenResponse
func (p *GeetcacheServiceListLenResult) GetSuccess() *ListLenResponse {
  if !p.IsSetSuccess() {
    return GeetcacheServiceListLenResult_Success_DEFAULT
  }
return p.Success
}
func (p *GeetcacheServiceListLenResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *GeetcacheServiceListLenResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *GeetcacheServiceListLenResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &ListLenResponse{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *GeetcacheServiceListLenResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "ListLen_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *GeetcacheServiceListLenResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *GeetcacheServiceListLenResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("GeetcacheServiceListLenResult(%+v)", *p)
}

// Attributes:
//  - Key
type GeetcacheServiceGetArgs struct {
  Key string `thrift:"key,1" db:"key" json:"key"`
}

func NewGeetcacheServiceGetArgs() *GeetcacheServiceGetArgs {
  return &GeetcacheServiceGetArgs{}
}


func (p *GeetcacheServiceGetArgs) GetKey() string {
  return p.Key
}
func (p *GeetcacheServiceGetArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *GeetcacheServiceGetArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Key = v
}
  return nil
}

func (p *GeetcacheServiceGetArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "Get_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *GeetcacheServiceGetArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "key", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:key: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Key)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.key (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:key: ", p), err) }
  return err
}

func (p *GeetcacheServiceGetArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("GeetcacheServiceGetArgs(%+v)", *p)
}

// Attributes:
//  - Success
type GeetcacheServiceGetResult struct {
  Success *GetResponse `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewGeetcacheServiceGetResult() *GeetcacheServiceGetResult {
  return &GeetcacheServiceGetResult{}
}

var GeetcacheServiceGetResult_Success_DEFAULT *GetResponse
func (p *GeetcacheServiceGetResult) GetSuccess() *GetResponse {
  if !p.IsSetSuccess() {
    return GeetcacheServiceGetResult_Success_DEFAULT
  }
return p.Success
}
func (p *GeetcacheServiceGetResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *GeetcacheServiceGetResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *GeetcacheServiceGetResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &GetResponse{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *GeetcacheServiceGetResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "Get_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *GeetcacheServiceGetResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *GeetcacheServiceGetResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("GeetcacheServiceGetResult(%+v)", *p)
}

// Attributes:
//  - Key
type GeetcacheServiceDeleteArgs struct {
  Key string `thrift:"key,1" db:"key" json:"key"`
}

func NewGeetcacheServiceDeleteArgs() *GeetcacheServiceDeleteArgs {
  return &GeetcacheServiceDeleteArgs{}
}


func (p *GeetcacheServiceDeleteArgs) GetKey() string {
  return p.Key
}
func (p *GeetcacheServiceDeleteArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *GeetcacheServiceDeleteArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Key = v
}
  return nil
}

func (p *GeetcacheServiceDeleteArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "Delete_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *GeetcacheServiceDeleteArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "key", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:key: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Key)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.key (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:key: ", p), err) }
  return err
}

func (p *GeetcacheServiceDeleteArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("GeetcacheServiceDeleteArgs(%+v)", *p)
}

// Attributes:
//  - Success
type GeetcacheServiceDeleteResult struct {
  Success *DelResponse `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewGeetcacheServiceDeleteResult() *GeetcacheServiceDeleteResult {
  return &GeetcacheServiceDeleteResult{}
}

var GeetcacheServiceDeleteResult_Success_DEFAULT *DelResponse
func (p *GeetcacheServiceDeleteResult) GetSuccess() *DelResponse {
  if !p.IsSetSuccess() {
    return GeetcacheServiceDeleteResult_Success_DEFAULT
  }
return p.Success
}
func (p *GeetcacheServiceDeleteResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *GeetcacheServiceDeleteResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *GeetcacheServiceDeleteResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &DelResponse{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *GeetcacheServiceDeleteResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "Delete_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *GeetcacheServiceDeleteResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *GeetcacheServiceDeleteResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("GeetcacheServiceDeleteResult(%+v)", *p)
}

// Attributes:
//  - Key
type GeetcacheServiceDeleteListArgs struct {
  Key string `thrift:"key,1" db:"key" json:"key"`
}

func NewGeetcacheServiceDeleteListArgs() *GeetcacheServiceDeleteListArgs {
  return &GeetcacheServiceDeleteListArgs{}
}


func (p *GeetcacheServiceDeleteListArgs) GetKey() string {
  return p.Key
}
func (p *GeetcacheServiceDeleteListArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *GeetcacheServiceDeleteListArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Key = v
}
  return nil
}

func (p *GeetcacheServiceDeleteListArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "DeleteList_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *GeetcacheServiceDeleteListArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "key", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:key: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Key)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.key (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:key: ", p), err) }
  return err
}

func (p *GeetcacheServiceDeleteListArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("GeetcacheServiceDeleteListArgs(%+v)", *p)
}

// Attributes:
//  - Success
type GeetcacheServiceDeleteListResult struct {
  Success *DelResponse `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewGeetcacheServiceDeleteListResult() *GeetcacheServiceDeleteListResult {
  return &GeetcacheServiceDeleteListResult{}
}

var GeetcacheServiceDeleteListResult_Success_DEFAULT *DelResponse
func (p *GeetcacheServiceDeleteListResult) GetSuccess() *DelResponse {
  if !p.IsSetSuccess() {
    return GeetcacheServiceDeleteListResult_Success_DEFAULT
  }
return p.Success
}
func (p *GeetcacheServiceDeleteListResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *GeetcacheServiceDeleteListResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *GeetcacheServiceDeleteListResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &DelResponse{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *GeetcacheServiceDeleteListResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "DeleteList_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *GeetcacheServiceDeleteListResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *GeetcacheServiceDeleteListResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("GeetcacheServiceDeleteListResult(%+v)", *p)
}

type GeetcacheServiceLeaderArgs struct {
}

func NewGeetcacheServiceLeaderArgs() *GeetcacheServiceLeaderArgs {
  return &GeetcacheServiceLeaderArgs{}
}

func (p *GeetcacheServiceLeaderArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *GeetcacheServiceLeaderArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "Leader_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *GeetcacheServiceLeaderArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("GeetcacheServiceLeaderArgs(%+v)", *p)
}

// Attributes:
//  - Success
type GeetcacheServiceLeaderResult struct {
  Success *LeaderResponse `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewGeetcacheServiceLeaderResult() *GeetcacheServiceLeaderResult {
  return &GeetcacheServiceLeaderResult{}
}

var GeetcacheServiceLeaderResult_Success_DEFAULT *LeaderResponse
func (p *GeetcacheServiceLeaderResult) GetSuccess() *LeaderResponse {
  if !p.IsSetSuccess() {
    return GeetcacheServiceLeaderResult_Success_DEFAULT
  }
return p.Success
}
func (p *GeetcacheServiceLeaderResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *GeetcacheServiceLeaderResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *GeetcacheServiceLeaderResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &LeaderResponse{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *GeetcacheServiceLeaderResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "Leader_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *GeetcacheServiceLeaderResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *GeetcacheServiceLeaderResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("GeetcacheServiceLeaderResult(%+v)", *p)
}

type GeetcacheServicePeersArgs struct {
}

func NewGeetcacheServicePeersArgs() *GeetcacheServicePeersArgs {
  return &GeetcacheServicePeersArgs{}
}

func (p *GeetcacheServicePeersArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *GeetcacheServicePeersArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "Peers_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *GeetcacheServicePeersArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("GeetcacheServicePeersArgs(%+v)", *p)
}

// Attributes:
//  - Success
type GeetcacheServicePeersResult struct {
  Success *PeersResponse `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewGeetcacheServicePeersResult() *GeetcacheServicePeersResult {
  return &GeetcacheServicePeersResult{}
}

var GeetcacheServicePeersResult_Success_DEFAULT *PeersResponse
func (p *GeetcacheServicePeersResult) GetSuccess() *PeersResponse {
  if !p.IsSetSuccess() {
    return GeetcacheServicePeersResult_Success_DEFAULT
  }
return p.Success
}
func (p *GeetcacheServicePeersResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *GeetcacheServicePeersResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *GeetcacheServicePeersResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &PeersResponse{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *GeetcacheServicePeersResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "Peers_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *GeetcacheServicePeersResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *GeetcacheServicePeersResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("GeetcacheServicePeersResult(%+v)", *p)
}

// Attributes:
//  - Counter
type GeetcacheServiceAddCounterArgs struct {
  Counter *CAddCommand `thrift:"counter,1" db:"counter" json:"counter"`
}

func NewGeetcacheServiceAddCounterArgs() *GeetcacheServiceAddCounterArgs {
  return &GeetcacheServiceAddCounterArgs{}
}

var GeetcacheServiceAddCounterArgs_Counter_DEFAULT *CAddCommand
func (p *GeetcacheServiceAddCounterArgs) GetCounter() *CAddCommand {
  if !p.IsSetCounter() {
    return GeetcacheServiceAddCounterArgs_Counter_DEFAULT
  }
return p.Counter
}
func (p *GeetcacheServiceAddCounterArgs) IsSetCounter() bool {
  return p.Counter != nil
}

func (p *GeetcacheServiceAddCounterArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *GeetcacheServiceAddCounterArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Counter = &CAddCommand{}
  if err := p.Counter.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Counter), err)
  }
  return nil
}

func (p *GeetcacheServiceAddCounterArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "AddCounter_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *GeetcacheServiceAddCounterArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "counter", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:counter: ", p), err) }
  if err := p.Counter.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Counter), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:counter: ", p), err) }
  return err
}

func (p *GeetcacheServiceAddCounterArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("GeetcacheServiceAddCounterArgs(%+v)", *p)
}

// Attributes:
//  - Success
type GeetcacheServiceAddCounterResult struct {
  Success *Status `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewGeetcacheServiceAddCounterResult() *GeetcacheServiceAddCounterResult {
  return &GeetcacheServiceAddCounterResult{}
}

var GeetcacheServiceAddCounterResult_Success_DEFAULT Status
func (p *GeetcacheServiceAddCounterResult) GetSuccess() Status {
  if !p.IsSetSuccess() {
    return GeetcacheServiceAddCounterResult_Success_DEFAULT
  }
return *p.Success
}
func (p *GeetcacheServiceAddCounterResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *GeetcacheServiceAddCounterResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *GeetcacheServiceAddCounterResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  temp := Status(v)
  p.Success = &temp
}
  return nil
}

func (p *GeetcacheServiceAddCounterResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "AddCounter_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *GeetcacheServiceAddCounterResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *GeetcacheServiceAddCounterResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("GeetcacheServiceAddCounterResult(%+v)", *p)
}

// Attributes:
//  - CounterName
type GeetcacheServiceDeleteCounterArgs struct {
  CounterName string `thrift:"counterName,1" db:"counterName" json:"counterName"`
}

func NewGeetcacheServiceDeleteCounterArgs() *GeetcacheServiceDeleteCounterArgs {
  return &GeetcacheServiceDeleteCounterArgs{}
}


func (p *GeetcacheServiceDeleteCounterArgs) GetCounterName() string {
  return p.CounterName
}
func (p *GeetcacheServiceDeleteCounterArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *GeetcacheServiceDeleteCounterArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.CounterName = v
}
  return nil
}

func (p *GeetcacheServiceDeleteCounterArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "DeleteCounter_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *GeetcacheServiceDeleteCounterArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "counterName", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:counterName: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.CounterName)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.counterName (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:counterName: ", p), err) }
  return err
}

func (p *GeetcacheServiceDeleteCounterArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("GeetcacheServiceDeleteCounterArgs(%+v)", *p)
}

// Attributes:
//  - Success
type GeetcacheServiceDeleteCounterResult struct {
  Success *Status `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewGeetcacheServiceDeleteCounterResult() *GeetcacheServiceDeleteCounterResult {
  return &GeetcacheServiceDeleteCounterResult{}
}

var GeetcacheServiceDeleteCounterResult_Success_DEFAULT Status
func (p *GeetcacheServiceDeleteCounterResult) GetSuccess() Status {
  if !p.IsSetSuccess() {
    return GeetcacheServiceDeleteCounterResult_Success_DEFAULT
  }
return *p.Success
}
func (p *GeetcacheServiceDeleteCounterResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *GeetcacheServiceDeleteCounterResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *GeetcacheServiceDeleteCounterResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  temp := Status(v)
  p.Success = &temp
}
  return nil
}

func (p *GeetcacheServiceDeleteCounterResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "DeleteCounter_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *GeetcacheServiceDeleteCounterResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *GeetcacheServiceDeleteCounterResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("GeetcacheServiceDeleteCounterResult(%+v)", *p)
}

// Attributes:
//  - Counter
type GeetcacheServiceIncreamentArgs struct {
  Counter *CChangeCommand `thrift:"counter,1" db:"counter" json:"counter"`
}

func NewGeetcacheServiceIncreamentArgs() *GeetcacheServiceIncreamentArgs {
  return &GeetcacheServiceIncreamentArgs{}
}

var GeetcacheServiceIncreamentArgs_Counter_DEFAULT *CChangeCommand
func (p *GeetcacheServiceIncreamentArgs) GetCounter() *CChangeCommand {
  if !p.IsSetCounter() {
    return GeetcacheServiceIncreamentArgs_Counter_DEFAULT
  }
return p.Counter
}
func (p *GeetcacheServiceIncreamentArgs) IsSetCounter() bool {
  return p.Counter != nil
}

func (p *GeetcacheServiceIncreamentArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *GeetcacheServiceIncreamentArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Counter = &CChangeCommand{}
  if err := p.Counter.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Counter), err)
  }
  return nil
}

func (p *GeetcacheServiceIncreamentArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "Increament_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *GeetcacheServiceIncreamentArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "counter", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:counter: ", p), err) }
  if err := p.Counter.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Counter), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:counter: ", p), err) }
  return err
}

func (p *GeetcacheServiceIncreamentArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("GeetcacheServiceIncreamentArgs(%+v)", *p)
}

// Attributes:
//  - Success
type GeetcacheServiceIncreamentResult struct {
  Success *CStatus `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewGeetcacheServiceIncreamentResult() *GeetcacheServiceIncreamentResult {
  return &GeetcacheServiceIncreamentResult{}
}

var GeetcacheServiceIncreamentResult_Success_DEFAULT *CStatus
func (p *GeetcacheServiceIncreamentResult) GetSuccess() *CStatus {
  if !p.IsSetSuccess() {
    return GeetcacheServiceIncreamentResult_Success_DEFAULT
  }
return p.Success
}
func (p *GeetcacheServiceIncreamentResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *GeetcacheServiceIncreamentResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *GeetcacheServiceIncreamentResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &CStatus{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *GeetcacheServiceIncreamentResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "Increament_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *GeetcacheServiceIncreamentResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *GeetcacheServiceIncreamentResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("GeetcacheServiceIncreamentResult(%+v)", *p)
}

// Attributes:
//  - Counter
type GeetcacheServiceDecrementArgs struct {
  Counter *CChangeCommand `thrift:"counter,1" db:"counter" json:"counter"`
}

func NewGeetcacheServiceDecrementArgs() *GeetcacheServiceDecrementArgs {
  return &GeetcacheServiceDecrementArgs{}
}

var GeetcacheServiceDecrementArgs_Counter_DEFAULT *CChangeCommand
func (p *GeetcacheServiceDecrementArgs) GetCounter() *CChangeCommand {
  if !p.IsSetCounter() {
    return GeetcacheServiceDecrementArgs_Counter_DEFAULT
  }
return p.Counter
}
func (p *GeetcacheServiceDecrementArgs) IsSetCounter() bool {
  return p.Counter != nil
}

func (p *GeetcacheServiceDecrementArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *GeetcacheServiceDecrementArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Counter = &CChangeCommand{}
  if err := p.Counter.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Counter), err)
  }
  return nil
}

func (p *GeetcacheServiceDecrementArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "Decrement_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *GeetcacheServiceDecrementArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "counter", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:counter: ", p), err) }
  if err := p.Counter.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Counter), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:counter: ", p), err) }
  return err
}

func (p *GeetcacheServiceDecrementArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("GeetcacheServiceDecrementArgs(%+v)", *p)
}

// Attributes:
//  - Success
type GeetcacheServiceDecrementResult struct {
  Success *CStatus `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewGeetcacheServiceDecrementResult() *GeetcacheServiceDecrementResult {
  return &GeetcacheServiceDecrementResult{}
}

var GeetcacheServiceDecrementResult_Success_DEFAULT *CStatus
func (p *GeetcacheServiceDecrementResult) GetSuccess() *CStatus {
  if !p.IsSetSuccess() {
    return GeetcacheServiceDecrementResult_Success_DEFAULT
  }
return p.Success
}
func (p *GeetcacheServiceDecrementResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *GeetcacheServiceDecrementResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *GeetcacheServiceDecrementResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &CStatus{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *GeetcacheServiceDecrementResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "Decrement_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *GeetcacheServiceDecrementResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *GeetcacheServiceDecrementResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("GeetcacheServiceDecrementResult(%+v)", *p)
}

// Attributes:
//  - CounterName
type GeetcacheServiceGetCounterValueArgs struct {
  CounterName string `thrift:"counterName,1" db:"counterName" json:"counterName"`
}

func NewGeetcacheServiceGetCounterValueArgs() *GeetcacheServiceGetCounterValueArgs {
  return &GeetcacheServiceGetCounterValueArgs{}
}


func (p *GeetcacheServiceGetCounterValueArgs) GetCounterName() string {
  return p.CounterName
}
func (p *GeetcacheServiceGetCounterValueArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *GeetcacheServiceGetCounterValueArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.CounterName = v
}
  return nil
}

func (p *GeetcacheServiceGetCounterValueArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "GetCounterValue_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *GeetcacheServiceGetCounterValueArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "counterName", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:counterName: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.CounterName)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.counterName (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:counterName: ", p), err) }
  return err
}

func (p *GeetcacheServiceGetCounterValueArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("GeetcacheServiceGetCounterValueArgs(%+v)", *p)
}

// Attributes:
//  - Success
type GeetcacheServiceGetCounterValueResult struct {
  Success *CStatus `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewGeetcacheServiceGetCounterValueResult() *GeetcacheServiceGetCounterValueResult {
  return &GeetcacheServiceGetCounterValueResult{}
}

var GeetcacheServiceGetCounterValueResult_Success_DEFAULT *CStatus
func (p *GeetcacheServiceGetCounterValueResult) GetSuccess() *CStatus {
  if !p.IsSetSuccess() {
    return GeetcacheServiceGetCounterValueResult_Success_DEFAULT
  }
return p.Success
}
func (p *GeetcacheServiceGetCounterValueResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *GeetcacheServiceGetCounterValueResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *GeetcacheServiceGetCounterValueResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &CStatus{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *GeetcacheServiceGetCounterValueResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "GetCounterValue_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *GeetcacheServiceGetCounterValueResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *GeetcacheServiceGetCounterValueResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("GeetcacheServiceGetCounterValueResult(%+v)", *p)
}

// Attributes:
//  - Cas
type GeetcacheServiceCompSwapArgs struct {
  Cas *CASCommand `thrift:"cas,1" db:"cas" json:"cas"`
}

func NewGeetcacheServiceCompSwapArgs() *GeetcacheServiceCompSwapArgs {
  return &GeetcacheServiceCompSwapArgs{}
}

var GeetcacheServiceCompSwapArgs_Cas_DEFAULT *CASCommand
func (p *GeetcacheServiceCompSwapArgs) GetCas() *CASCommand {
  if !p.IsSetCas() {
    return GeetcacheServiceCompSwapArgs_Cas_DEFAULT
  }
return p.Cas
}
func (p *GeetcacheServiceCompSwapArgs) IsSetCas() bool {
  return p.Cas != nil
}

func (p *GeetcacheServiceCompSwapArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *GeetcacheServiceCompSwapArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Cas = &CASCommand{}
  if err := p.Cas.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Cas), err)
  }
  return nil
}

func (p *GeetcacheServiceCompSwapArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "CompSwap_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *GeetcacheServiceCompSwapArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "cas", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:cas: ", p), err) }
  if err := p.Cas.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Cas), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:cas: ", p), err) }
  return err
}

func (p *GeetcacheServiceCompSwapArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("GeetcacheServiceCompSwapArgs(%+v)", *p)
}

// Attributes:
//  - Success
type GeetcacheServiceCompSwapResult struct {
  Success *Status `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewGeetcacheServiceCompSwapResult() *GeetcacheServiceCompSwapResult {
  return &GeetcacheServiceCompSwapResult{}
}

var GeetcacheServiceCompSwapResult_Success_DEFAULT Status
func (p *GeetcacheServiceCompSwapResult) GetSuccess() Status {
  if !p.IsSetSuccess() {
    return GeetcacheServiceCompSwapResult_Success_DEFAULT
  }
return *p.Success
}
func (p *GeetcacheServiceCompSwapResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *GeetcacheServiceCompSwapResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *GeetcacheServiceCompSwapResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  temp := Status(v)
  p.Success = &temp
}
  return nil
}

func (p *GeetcacheServiceCompSwapResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "CompSwap_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *GeetcacheServiceCompSwapResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *GeetcacheServiceCompSwapResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("GeetcacheServiceCompSwapResult(%+v)", *p)
}

// Attributes:
//  - Hlcmd
type GeetcacheServiceHLogCreateArgs struct {
  Hlcmd *HLogCreateCmd `thrift:"hlcmd,1" db:"hlcmd" json:"hlcmd"`
}

func NewGeetcacheServiceHLogCreateArgs() *GeetcacheServiceHLogCreateArgs {
  return &GeetcacheServiceHLogCreateArgs{}
}

var GeetcacheServiceHLogCreateArgs_Hlcmd_DEFAULT *HLogCreateCmd
func (p *GeetcacheServiceHLogCreateArgs) GetHlcmd() *HLogCreateCmd {
  if !p.IsSetHlcmd() {
    return GeetcacheServiceHLogCreateArgs_Hlcmd_DEFAULT
  }
return p.Hlcmd
}
func (p *GeetcacheServiceHLogCreateArgs) IsSetHlcmd() bool {
  return p.Hlcmd != nil
}

func (p *GeetcacheServiceHLogCreateArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *GeetcacheServiceHLogCreateArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Hlcmd = &HLogCreateCmd{}
  if err := p.Hlcmd.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Hlcmd), err)
  }
  return nil
}

func (p *GeetcacheServiceHLogCreateArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "HLogCreate_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *GeetcacheServiceHLogCreateArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "hlcmd", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:hlcmd: ", p), err) }
  if err := p.Hlcmd.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Hlcmd), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:hlcmd: ", p), err) }
  return err
}

func (p *GeetcacheServiceHLogCreateArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("GeetcacheServiceHLogCreateArgs(%+v)", *p)
}

// Attributes:
//  - Success
type GeetcacheServiceHLogCreateResult struct {
  Success *HLogStatus `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewGeetcacheServiceHLogCreateResult() *GeetcacheServiceHLogCreateResult {
  return &GeetcacheServiceHLogCreateResult{}
}

var GeetcacheServiceHLogCreateResult_Success_DEFAULT *HLogStatus
func (p *GeetcacheServiceHLogCreateResult) GetSuccess() *HLogStatus {
  if !p.IsSetSuccess() {
    return GeetcacheServiceHLogCreateResult_Success_DEFAULT
  }
return p.Success
}
func (p *GeetcacheServiceHLogCreateResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *GeetcacheServiceHLogCreateResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *GeetcacheServiceHLogCreateResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &HLogStatus{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *GeetcacheServiceHLogCreateResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "HLogCreate_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *GeetcacheServiceHLogCreateResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *GeetcacheServiceHLogCreateResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("GeetcacheServiceHLogCreateResult(%+v)", *p)
}

// Attributes:
//  - Key
type GeetcacheServiceHLogDeleteArgs struct {
  Key string `thrift:"key,1" db:"key" json:"key"`
}

func NewGeetcacheServiceHLogDeleteArgs() *GeetcacheServiceHLogDeleteArgs {
  return &GeetcacheServiceHLogDeleteArgs{}
}


func (p *GeetcacheServiceHLogDeleteArgs) GetKey() string {
  return p.Key
}
func (p *GeetcacheServiceHLogDeleteArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *GeetcacheServiceHLogDeleteArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Key = v
}
  return nil
}

func (p *GeetcacheServiceHLogDeleteArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "HLogDelete_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *GeetcacheServiceHLogDeleteArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "key", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:key: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Key)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.key (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:key: ", p), err) }
  return err
}

func (p *GeetcacheServiceHLogDeleteArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("GeetcacheServiceHLogDeleteArgs(%+v)", *p)
}

// Attributes:
//  - Success
type GeetcacheServiceHLogDeleteResult struct {
  Success *HLogStatus `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewGeetcacheServiceHLogDeleteResult() *GeetcacheServiceHLogDeleteResult {
  return &GeetcacheServiceHLogDeleteResult{}
}

var GeetcacheServiceHLogDeleteResult_Success_DEFAULT *HLogStatus
func (p *GeetcacheServiceHLogDeleteResult) GetSuccess() *HLogStatus {
  if !p.IsSetSuccess() {
    return GeetcacheServiceHLogDeleteResult_Success_DEFAULT
  }
return p.Success
}
func (p *GeetcacheServiceHLogDeleteResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *GeetcacheServiceHLogDeleteResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *GeetcacheServiceHLogDeleteResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &HLogStatus{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *GeetcacheServiceHLogDeleteResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "HLogDelete_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *GeetcacheServiceHLogDeleteResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *GeetcacheServiceHLogDeleteResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("GeetcacheServiceHLogDeleteResult(%+v)", *p)
}

// Attributes:
//  - Key
type GeetcacheServiceHLogCardinalityArgs struct {
  Key string `thrift:"key,1" db:"key" json:"key"`
}

func NewGeetcacheServiceHLogCardinalityArgs() *GeetcacheServiceHLogCardinalityArgs {
  return &GeetcacheServiceHLogCardinalityArgs{}
}


func (p *GeetcacheServiceHLogCardinalityArgs) GetKey() string {
  return p.Key
}
func (p *GeetcacheServiceHLogCardinalityArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *GeetcacheServiceHLogCardinalityArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Key = v
}
  return nil
}

func (p *GeetcacheServiceHLogCardinalityArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "HLogCardinality_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *GeetcacheServiceHLogCardinalityArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "key", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:key: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Key)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.key (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:key: ", p), err) }
  return err
}

func (p *GeetcacheServiceHLogCardinalityArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("GeetcacheServiceHLogCardinalityArgs(%+v)", *p)
}

// Attributes:
//  - Success
type GeetcacheServiceHLogCardinalityResult struct {
  Success *HLogStatus `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewGeetcacheServiceHLogCardinalityResult() *GeetcacheServiceHLogCardinalityResult {
  return &GeetcacheServiceHLogCardinalityResult{}
}

var GeetcacheServiceHLogCardinalityResult_Success_DEFAULT *HLogStatus
func (p *GeetcacheServiceHLogCardinalityResult) GetSuccess() *HLogStatus {
  if !p.IsSetSuccess() {
    return GeetcacheServiceHLogCardinalityResult_Success_DEFAULT
  }
return p.Success
}
func (p *GeetcacheServiceHLogCardinalityResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *GeetcacheServiceHLogCardinalityResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *GeetcacheServiceHLogCardinalityResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &HLogStatus{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *GeetcacheServiceHLogCardinalityResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "HLogCardinality_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *GeetcacheServiceHLogCardinalityResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *GeetcacheServiceHLogCardinalityResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("GeetcacheServiceHLogCardinalityResult(%+v)", *p)
}

// Attributes:
//  - Hladd
type GeetcacheServiceHLogAddArgs struct {
  Hladd *HLogAddCmd `thrift:"hladd,1" db:"hladd" json:"hladd"`
}

func NewGeetcacheServiceHLogAddArgs() *GeetcacheServiceHLogAddArgs {
  return &GeetcacheServiceHLogAddArgs{}
}

var GeetcacheServiceHLogAddArgs_Hladd_DEFAULT *HLogAddCmd
func (p *GeetcacheServiceHLogAddArgs) GetHladd() *HLogAddCmd {
  if !p.IsSetHladd() {
    return GeetcacheServiceHLogAddArgs_Hladd_DEFAULT
  }
return p.Hladd
}
func (p *GeetcacheServiceHLogAddArgs) IsSetHladd() bool {
  return p.Hladd != nil
}

func (p *GeetcacheServiceHLogAddArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *GeetcacheServiceHLogAddArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Hladd = &HLogAddCmd{}
  if err := p.Hladd.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Hladd), err)
  }
  return nil
}

func (p *GeetcacheServiceHLogAddArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "HLogAdd_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *GeetcacheServiceHLogAddArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "hladd", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:hladd: ", p), err) }
  if err := p.Hladd.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Hladd), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:hladd: ", p), err) }
  return err
}

func (p *GeetcacheServiceHLogAddArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("GeetcacheServiceHLogAddArgs(%+v)", *p)
}

// Attributes:
//  - Success
type GeetcacheServiceHLogAddResult struct {
  Success *HLogStatus `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewGeetcacheServiceHLogAddResult() *GeetcacheServiceHLogAddResult {
  return &GeetcacheServiceHLogAddResult{}
}

var GeetcacheServiceHLogAddResult_Success_DEFAULT *HLogStatus
func (p *GeetcacheServiceHLogAddResult) GetSuccess() *HLogStatus {
  if !p.IsSetSuccess() {
    return GeetcacheServiceHLogAddResult_Success_DEFAULT
  }
return p.Success
}
func (p *GeetcacheServiceHLogAddResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *GeetcacheServiceHLogAddResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *GeetcacheServiceHLogAddResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &HLogStatus{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *GeetcacheServiceHLogAddResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "HLogAdd_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *GeetcacheServiceHLogAddResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *GeetcacheServiceHLogAddResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("GeetcacheServiceHLogAddResult(%+v)", *p)
}


